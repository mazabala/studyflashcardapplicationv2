import { FontSizes, FontSizeTags, FontWeights, StackAlignment, StackDirection, StackDistribution, } from "./types.js";
/**
 * Generates CSS spacing styles for margin or padding
 * @param spacing - The spacing object containing top, trailing, bottom, and leading values
 * @param spacingKey - The type of spacing ('margin' or 'padding')
 * @returns CSS style object with logical properties for spacing
 */
function getSpacingStyle(spacing, spacingKey) {
    if (!spacing || !spacingKey)
        return "";
    return {
        [`--${spacingKey}-block-start`]: `${spacing.top ?? 0}px`,
        [`--${spacingKey}-inline-end`]: `${spacing.trailing ?? 0}px`,
        [`--${spacingKey}-block-end`]: `${spacing.bottom ?? 0}px`,
        [`--${spacingKey}-inline-start`]: `${spacing.leading ?? 0}px`,
    };
}
/**
 * Maps font size to appropriate HTML heading tag
 * @param fontSize - Key from FontSizeTags enum
 * @returns Corresponding HTML heading tag
 */
export function getTextComponentTag(fontSize) {
    return FontSizeTags[fontSize];
}
/**
 * Gets color value based on color mode with fallback
 * @param params - Object containing color map, mode and fallback color
 * @returns Color value as string
 */
function getColor({ colorMap, colorMode = "light", fallback = "FFFFFF", }) {
    return colorMap?.[colorMode]?.value || fallback;
}
/**
 * Generates CSS border style string
 * @param border - Border configuration object
 * @param colorMode - Color mode (light/dark)
 * @returns CSS border style string
 */
function getBorderStyle(border, colorMode = "light") {
    const color = getColor({ colorMap: border.color, colorMode });
    return `${border.width}px solid ${color}`;
}
/**
 * Generates CSS border radius style for corners
 * @param corners - Corner radius configuration
 * @returns CSS border radius string
 */
function getCornerRadiusStyle(corners) {
    return `${corners.top_leading}px ${corners.top_trailing}px ${corners.bottom_trailing}px ${corners.bottom_leading}px`;
}
/**
 * Generates comprehensive component styles including spacing, colors, borders and shadows
 * @param params - Component style configuration object
 * @returns CSS style object with component styles
 */
export function getComponentStyles({ backgroundColor, border, margin, padding, textColor, colorMode = "light", shape, shadow, }) {
    const stylesObject = {
        "--margin-block-start": "0px",
        "--margin-inline-end": "0px",
        "--margin-block-end": "0px",
        "--margin-inline-start": "0px",
        "--padding-block-start": "0px",
        "--padding-inline-end": "0px",
        "--padding-block-end": "0px",
        "--padding-inline-start": "0px",
        "--background-color": "transparent",
        "--text-color": "#000000",
        "--border": "none",
        "--border-radius": "0px",
        "--shadow": "none",
    };
    if (padding) {
        Object.assign(stylesObject, getSpacingStyle(padding, "padding"));
    }
    if (margin) {
        Object.assign(stylesObject, getSpacingStyle(margin, "margin"));
    }
    if (backgroundColor) {
        stylesObject["--background-color"] = getColor({
            colorMap: backgroundColor,
            colorMode,
            fallback: "transparent",
        });
    }
    if (textColor) {
        stylesObject["--text-color"] = getColor({
            colorMap: textColor,
            colorMode,
            fallback: "#000000",
        });
    }
    if (border) {
        stylesObject["--border"] = getBorderStyle(border, colorMode);
    }
    if (shape?.type === "rectangle" && shape.corners) {
        stylesObject["--border-radius"] = getCornerRadiusStyle(shape.corners);
    }
    if (shape?.type === "pill") {
        stylesObject["--border-radius"] = "9999px;";
    }
    if (shadow) {
        stylesObject["--shadow"] = `${shadow.x}px ${shadow.y}px ${shadow.radius}px 
      ${getColor({ colorMap: shadow.color, colorMode, fallback: "#000000" })};`;
    }
    return stylesObject;
}
/**
 * Generates size-related CSS styles for components
 * @param size - Size configuration object
 * @returns CSS style object with size properties
 */
export function getSizeStyle(size) {
    function getSizeValue(size) {
        if (size.type === "fixed") {
            return `${size.value}px`;
        }
        if (size.type === "fit") {
            return "fit-content";
        }
        if (size.type === "fill") {
            const userAgent = navigator.userAgent;
            const isFirefox = userAgent.match(/firefox|fxios/i);
            return isFirefox ? "-moz-available" : "-webkit-fill-available";
        }
        return "unset";
    }
    const width = getSizeValue(size.width);
    const height = getSizeValue(size.height);
    const isGrow = size.width.type === "fill" || size.height.type === "fill";
    return {
        "--width": width,
        "--height": height,
        "--flex": isGrow ? "unset" : "0 1 auto",
    };
}
/**
 * Generates gradient background styles
 * @param colorMode - Color mode (light/dark)
 * @param gradientColors - Array of colors for gradient
 * @returns CSS style object with gradient background
 */
export function getGradientStyle(colorMode, gradientColors) {
    if (!gradientColors)
        return { "--background": "unset" };
    return {
        "--background": `linear-gradient(${gradientColors.map((color) => color[colorMode]?.value).join(", ")})`,
    };
}
/**
 * Generates mask styles for images
 * @param maskShape - Shape configuration for image mask
 * @returns CSS style object with mask properties
 */
export const getMaskStyle = (maskShape) => {
    let maskStyles = {
        "--corner-radius": "0px",
        "--clip-path": "none",
    };
    if (maskShape?.type === "circle") {
        maskStyles["--corner-radius"] = "50%";
    }
    if (maskShape?.type === "rectangle" && maskShape.corners) {
        maskStyles["--corner-radius"] = getCornerRadiusStyle(maskShape.corners);
    }
    // TODO: rework this implementation
    if (maskShape?.type === "convex") {
        maskStyles["--corner-radius"] = "0 0 50% 50%;";
    }
    if (maskShape?.type === "concave") {
        maskStyles["--clip-path"] =
            "polygon(0 0, 100% 0, 100% 100%, 50% 110%, 0 100%);";
    }
    return maskStyles;
};
/**
 * Generates dimension-related styles for stack components
 * @param dimension - Dimension configuration object
 * @returns CSS style object with flex layout properties
 */
export function getDimensionStyle(dimension) {
    const styles = {
        "--direction": "row",
        "--alignment": "unset",
        "--distribution": "unset",
    };
    if (dimension.type === "zlayer") {
        // TODO: Review with Monetization team
    }
    else {
        styles["--direction"] = StackDirection[dimension.type];
        styles["--alignment"] = StackAlignment[dimension.alignment];
        if (dimension.distribution) {
            styles["--distribution"] = StackDistribution[dimension.distribution];
        }
    }
    return styles;
}
/**
 * Generates text-related styles
 * @param props - Text component properties
 * @returns CSS style object with text formatting properties
 */
export function getTextStyles(props) {
    const { font_size, horizontal_alignment, font_weight, font_name } = props;
    const styles = {
        "--text-align": "initial",
        "--font-weight": 400,
        "--font-size": "initial",
        "--font-family": "sans-serif",
    };
    styles["--text-align"] = horizontal_alignment;
    styles["--font-weight"] = FontWeights[font_weight];
    styles["--font-size"] = FontSizes[font_size];
    styles["--font-family"] = font_name || "sans-serif";
    return styles;
}
/**
 * Converts a style object to a CSS string
 * @param styles - Object containing CSS properties and values
 * @returns CSS string
 */
export function stringifyStyles(styles) {
    return Object.entries(styles)
        .map(([key, value]) => `${key}: ${value};`)
        .join("; ");
}
/**
 * Given a ComponentLocalizations object and a locale returns the label with label_id in the chosen locale, if any. Falls
 * back to the label with the same label_id in the fallbackLocale, if any. Finally returns undefined if no label can be
 * found for the requested label_id.
 * @param label_id - The id of the label to be returned
 * @param locale - The preferred locale to return the label
 * @param fallbackLocale - The locale to fall back to in case no label is found in the preferred one
 * @param labels - A ComponentLocalizations instance
 * @returns The label in the preferred or fallback locale, or undefined.
 */
export function getLabelById(label_id, locale, fallbackLocale, labels) {
    const fallback = (labels[fallbackLocale] || {})[label_id];
    if (!(labels[locale] || {})[label_id]) {
        return fallback;
    }
    return labels[locale][label_id];
}
/**
 * Given an instance of PaywallData, returns the id of the first package marked as `is_selected_by_default` if any.
 * @param paywallData
 * @returns the id of the first package marked as `is_selected_by_default` or undefined
 */
export function findSelectedPackageId(paywallData) {
    const traverseNode = (node) => {
        if (node.type === "package" &&
            node.is_selected_by_default) {
            return node;
        }
        if (node.components) {
            for (let c of node.components) {
                const pkg = traverseNode(c);
                if (pkg) {
                    return pkg;
                }
            }
        }
        if (node.stack !== undefined) {
            const pkg = traverseNode(node.stack);
            if (pkg) {
                return pkg;
            }
        }
        return undefined;
    };
    const p = traverseNode(paywallData.components_config.base.stack);
    if (p === undefined) {
        return undefined;
    }
    return p.package_id;
}
